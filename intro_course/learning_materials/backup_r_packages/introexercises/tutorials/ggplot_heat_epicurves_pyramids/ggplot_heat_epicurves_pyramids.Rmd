---
title: "Applied Epi - Heat plots, epicurves, pyramids"
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
    css: css/css_custom.css
    theme: "paper"
runtime: shiny_prerendered
description: >
  Learn how to get started with R and RStudio, and how to import a dataset
---

<!-- NOTES: To edit images, edit them in the "images" folder that lives NEXT TO THE RMD FILE -->


<!-- Add JavaScript code for making the exercise code larger -->
<script language="JavaScript" src="js/exercise-font-size.js"></script>

```{r setup, include=FALSE}
library(gradethis)
library(etude)
library(learnr)
library(dplyr)
library(flair)
library(ggplot2)
library(lubridate)
library(forcats)
library(fontawesome)
library(scales)
library(stringr)
library(apyramid)
library(incidence2)
library(viridis)
library(janitor)
library(tidyr)

# set options for exercises and checking ---------------------------------------
gradethis::gradethis_setup()

learnr::tutorial_options(exercise.timelimit = 60)
    # exercise.checker = gradethis::grade_learnr) 
    # alternatively, submitr::null_code_checker

# event recorder ---------------------------------------------------------------
# see https://github.com/dtkaplan/submitr/blob/master/R/make_a_recorder.R

tutorial_options(exercise.eval = FALSE)  # pre-evaluate exercises

# new_recorder <- function(tutorial_id, tutorial_version, user_id, event, data) {
#     cat(
#       tutorial_id, 
#       " (v", tutorial_version, "); ",
#       format(Sys.time(), "%Y-%M%-%D %H:%M:%S %Z"), "; ",
#       user_id, "; ",
#       event, "; ",
#       data$label, "; ",
#       data$answers, "; ",
#       data$code, "; ",
#       data$correct, "\n", sep = "",
#       
#       file = here::here("event_records", "learnr_basics.txt"),
#       append = TRUE)
# }

#options(tutorial.event_recorder = new_recorder)
```


```{r, include=FALSE}
# hide non-exercise code chunks ------------------------------------------------
knitr::opts_chunk$set(echo = FALSE)
```

```{r, include=FALSE}
# data prep --------------------------------------------------------------------
combined <- rio::import(system.file("dat/linelist_combined_20141201.rds", package = "introexercises"))



# Create hospital weeks for heat plot
#####################################
# count cases by hospital-week
hospital_weeks_raw <- combined %>%
  count(hospital, week_onset) 

# create longer dataset of all possible hospital-weeks
expanded <- hospital_weeks_raw %>% 
  select(hospital, week_onset) %>%
  tidyr::expand(., week_onset, hospital)

# merge so that all hospital-weeks are represented in the data
hospital_weeks <- hospital_weeks_raw %>%      
  right_join(expanded) %>%                            
  mutate(n = replace_na(n, 0)) %>% 
  filter(week_onset >= ymd("2014-06-15"))






count_data <- combined %>% 
  group_by(hospital, date_hospitalisation) %>% 
  summarize(n_cases = dplyr::n()) %>% 
  ungroup()

hospitalisation_week <- incidence(combined,
          date_index = date_hospitalisation,
          interval = "weeks")

demo_agg <- combined %>% 
  count(age_cat, gender, name = "cases") %>% 
  pivot_wider(
    id_cols = age_cat,
    names_from = gender,
    values_from = cases) %>% 
  rename(`missing_gender` = `NA`)

aggregate_data <- demo_agg %>% 
  pivot_longer(
    col = c(female, male, missing_gender),            # cols to elongate
    names_to = "gender",                # name for new col of categories
    values_to = "counts") %>%           # name for new col of counts
  mutate(
    gender = na_if(gender, "missing_gender")) # convert "missing_gender" to NA

```




## Introduction to R for Applied Epidemiology and Public Health


### Welcome

Welcome to the live course "Introduction to R for applied epidemiologists", offered by [Applied Epi](www.appliedepi.org) - a nonprofit organisation that offers open-source tools, training, and support to frontline public health practitioners.  

```{r, eval = TRUE, echo = FALSE, out.width = "25%"}
knitr::include_graphics("images/logo.png", error = F)
```

### Heat plots, epidemic curves, and pyramids  

This exercise focuses on learning how to code and customize more advanced plots such as heat plots, epidemic curves and age/sex demographic pyramids. We will be building on what you have learned previously from tidyverse and ggplot2 to produce these.

This will involve using previously explored aspects such as:  

* `ggplot()`  
* Pipe chains `%>%`  
* Themes (e.g. `theme_minimal()`, `theme_bw()`)  
* Custom axis scales (e.g. `scale_y_continuous()`)  
* New functions such as `geom_tile()` for heat plots and `geom_histogram()` for epidemic curves, and `age_pyramid()` (from {apyramid}) for age/sex pyramids  


### Format

This exercise will guide you through a set of tasks.  
*You should perform these tasks in RStudio and on your local computer*.  

#### Getting Help  

There are several ways to get help:  

1) Look for the "helpers" (see below)
2) Ask your live course instructor/facilitator for help  
3) Ask a colleague or other participant in the course for tips  
4) Post a question in [Applied Epi Community](www.community.appliedepi.org) in the category for questions about Applied Epi Training  

Here is what those "helpers" will look like:

<!--
NOTE: Below is the hint (all within details tags collapsed)
-->
<details>

<summary style='text-decoration: underline; color: darkgreen;'>`r fontawesome::fa("lightbulb", fill = "gold")` Click to read a hint</summary>
</br>

Here you will see a helpful hint!  

</br>
</details>

<!--
NOTE: Below is the solution (all within details tags collapsed)
-->

<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>

```{r eval = F, echo=T}
linelist %>% 
  filter(
    age > 25,
    district == "Bolo"
  )
```

Here is more explanation about why the solution works.  

</br>
</details>
<!--
NOTE: End of solution
-->


#### Quiz questions  

Please complete the quiz questions that you encounter throughout the tutorial. **Answering will help you** to comprehend the material, and will also help us to improve the exercises for future students.  

To practice, please answer the following questions:  


```{r quiz-use-helper, echo=F}
quiz(
  question_radio("When should I view the red 'helper' code?",
    answer("After trying to write the code myself", correct = TRUE),
    answer("Before I try coding", correct = FALSE),
    correct = "Reviewing best-practice code after trying to write yourself can help you improve",
    incorrect = "Please attempt the exercise yourself, or use the hint, before viewing the answer."
  )
)
```


```{r quiz-anxious, echo = FALSE}
question_numeric(
 "How anxious are you about beginning this tutorial - on a scale from 1 (least anxious) to 10 (most anxious)?",
 answer(10, message = "Try not to worry, we will help you succeed!", correct = T),
 answer(9, message = "Try not to worry, we will help you succeed!", correct = T),
 answer(8, message = "Try not to worry, we will help you succeed!", correct = T),
 answer(7, message = "Try not to worry, we will help you succeed!", correct = T),
 answer(6, message = "Ok, we will get there together", correct = T),
 answer(5, message = "Ok, we will get there together", correct = T),
 answer(4, message = "I like your confidence!", correct = T),
 answer(3, message = "I like your confidence!", correct = T),
 answer(2, message = "I like your confidence!", correct = T),
 answer(1, message = "I like your confidence!", correct = T),
 allow_retry = TRUE,
 correct = "Thanks for sharing. ",
 min = 1,
 max = 10,
 step = 1
)
```



#### Icons  

You will see these icons throughout the exercises:

Icon  |Meaning
------|--------------------
`r fontawesome::fa("eye", fill = "darkblue")`|Observe  
`r fontawesome::fa("exclamation", fill = "red")`|Alert!  
`r fontawesome::fa("pen", fill = "brown")`|An informative note  
`r fontawesome::fa("terminal", fill = "black")`|Time for you to code!  
`r fontawesome::fa("window-restore", fill = "darkgrey")`|Change to another window  
`r fontawesome::fa("bookmark", fill = "orange")`|Remember this for later  




## Learning objectives  

In this exercise you will:  

* Practice reading R documentation for functions  
* Learn to make heat plots  
* Learn to make epidemic curves  
* Learn to make age/sex pyramids  





## Refresh your memory  

First, let us refresh ourselves on the basics of **ggplot2**!

```{r quiz1}
quiz(
  question("Where are dynamic aesthetics placed in ggplot code?",
    allow_retry = TRUE,
    answer("inside aes()", correct = T),
    answer("outside aes()", message = "dynamic assignments means the aesthetic is mapped to a column in the data, and the presentation can vary for each row. These must be done inside 'mapping = aes()'")
  ),
  question("Are static aesthetics in the initial ggplot() call inherited by subsequent geoms?",
    allow_retry = TRUE,
    answer("No", correct = TRUE),
    answer("Yes", message = "No, for example if you set the size of points equal to 3, the lines will not be size 3 as well.")
  ),
  question("Are dynamic aesthetics in the initial ggplot() call inherited by subsequent geoms?",
    allow_retry = TRUE,
    answer("No", message = "Yes they are, for example, assigning wt_kg to the X-axis is inherited by all the subsequent geoms."),
    answer("Yes", correct = TRUE)
  ),
    question("Should adjustments to the theme be made before or after setting one of the default themes?",
    allow_retry = TRUE,
    answer("before", message = "A complete/default theme will override all previous micro adjustments to the theme"),
    answer("after", correct = TRUE)
  ),
  question("Which of the following are prebuilt themes in ggplot",
    allow_retry = TRUE,
    answer("theme_bw()", correct = TRUE),
    answer("theme_classic()", correct = TRUE),
    answer("theme_red()"),
    answer("scale_color_brewer()")
  ),
  question("How would you hide a legend in ggplot?",
    allow_retry = TRUE,
    answer("theme(legend.title = 'element.blank()')"),
    answer("theme(legend.position = 'right')"),
    answer("theme(legend.position(none))"),
    answer("theme(legend.position = 'none')", correct = TRUE)
  ),
  question("How would you set your legend to appear in the centre of your graph?",
    answer("theme(legend.position = 'middle')"),
    answer("theme(legend.position =  c(0.5,0.5))", correct = TRUE)
  )
)
```

Great, now we have refreshed our memory with a quiz, we will start on our first topic, *heat plots*.





## Preparation  

Open your R project and run your entire "ebola_analysis.R" script, so that you are able to use the data frame `combined`.  

This will involve running all the parts of your R script, including to import data, clean, perform joins, and create the `combined` dataset.  

If you did not complete the joining exercise, or are seeing errors when trying to run your script, you can import a "backup" `combined` data frame in the "data/clean/backup/" folder using this command:  

```{r, echo=T, eval=F}
combined <- import(here("data", "clean", "backup", "linelist_combined_20141201.rds"))
```







## Heat plots

Heat plots, also called "heat tiles", are useful visualizations when trying to display **3 variables** (x-axis, y-axis and fill).  

For instance, you may want to look at a breakdown of how many cases were reported by week across several hospitals, to get an idea of how the epidemic has progressed in several places. Let's see how this works.  

Let's say that we have a data frame called `hospital_weeks`, which has the following columns:  

```{r, eval=T, echo=T}
head(hospital_weeks)    # print the first 6 rows
```

This data is in "long" format, and every possible hospital-week has a row.  



Create this data frame in your RStudio using this code below. *Do not try to understand this code (try our advanced course in data management)*. In essence it uses `count()` to create a data frame of case counts by week, then creates a data frame with all possible hospital-weeks, and then joins them together.  

```{r, echo = T, eval = T, message = F}
# count cases by hospital-week
hospital_weeks_raw <- combined %>%
  count(hospital, week_onset) 

# create longer dataset of all possible hospital-weeks
expanded <- hospital_weeks_raw %>% 
  select(hospital, week_onset) %>%
  tidyr::expand(., week_onset, hospital)

# merge so that all hospital-weeks are represented in the data
hospital_weeks <- hospital_weeks_raw %>%      
  right_join(expanded) %>%                            
  mutate(n = replace_na(n, 0)) %>% 
  filter(week_onset >= ymd("2014-06-15"))

```

### Review documentation  

`r fontawesome::fa("eye", fill = "darkblue")` Take a few minutes to review the documentation for the function `geom_tile()`, which is from {ggplot2}. You can access this by either:  

1) Entering `?geom_tile` in the Console, or  
2) Click to the "Help" pane (lower-right) and entering `geom_tile` in the search bar  



### Basic heat plot  

What `ggplot()` code would you write to create a heat plot that:  

* Has the week of onset on the x-axis  
* Has the hospital name on the y-axis  
* Is colored by the number of onsets in that week?

<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r eval = F, echo=T}
ggplot(data = hospital_weeks, mapping = aes(x = week_onset, y = hospital, fill = n)) +
  geom_tile()
```
</br>
</details>


```{r quiz1-2}
quiz(
  question("Which hospital reported the most cases with onset in September?",
    allow_retry = TRUE,
    answer("SMMH"),
    answer("Port Hospital", correct = T),
    answer("Military Hospital"),
    answer("Central Hospital"),
    answer("Unknown")
  ),
    question("Which hospital reported the highest case fatality ratio?",
    allow_retry = TRUE,
    answer("SMMH", message = "It is not possible to know the case fatality ratio from this plot"),
    answer("Port Hospital", message = "It is not possible to know the case fatality ratio from this plot"),
    answer("Military Hospital", message = "It is not possible to know the case fatality ratio from this plot"),
    answer("Central Hospital", message = "It is not possible to know the case fatality ratio from this plot"),
    answer("Unknown", correct = T)
    )
)
```




### Customising your heat plot

`r fontawesome::fa("terminal", fill = "black")` The plot is nice, but let us do a dew more things to refine the presentation:  

1) Modify `hospital_weeks` to create a new data frame: `hospital_weeks_adjusted`. In this data frame, ensure that:  
  * The `NA` values in the column `hospital` are re-coded as "Missing" *and* this column is class "factor" with the levels in this order : "Central Hospital", "Military Hospital", "Port Hospital", "SMMH", "Other", "Missing".  
  * You can convert `NA` to "(Missing)" using `fct_explicit_na()` from {forcats} within `mutate()`  
  * You can then use `fct_relevel()` also from {forcats}, in a subsequent `mutate()` to list the desired factor level order  
  


<!--
NOTE: Below is the hint (all within details tags collapsed)
-->
<details>

<summary style='text-decoration: underline; color: darkgreen;'>`r fontawesome::fa("lightbulb", fill = "gold")` Click to read a hint</summary>
</br>

Within `mutate()` commands, use the {forcats} package and its function `fct_explicit_na()` to re-define the column `hospital` to convert `NA` to "(Missing)" (this also converts the column to class "factor"). In another mutate command, use the function `fct_relevel()` to adjust the ordering of the levels.  

If you need a refresher on how to change `NA` values in factor columns, and how to reorder, checkout the R Handbook chapter on [factors](https://www.epirhandbook.com/en/factors.html?q=factor#factors).  

</br>
</details>


<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r, echo=T, eval=F}
hospital_weeks_adjusted <- hospital_weeks %>% 
  mutate(hospital = fct_explicit_na(hospital),
         hospital = fct_relevel(hospital, "Central Hospital", "Military Hospital", "Port Hospital", "SMMH", "Other", "(Missing)"))
```
</br>
</details>



2) In the ggplot *of the new adjust data frame*, change the color scheme to a diverging color scale. Provide a scale one that extends from "skyblue" at low values to "tomato" at high values.  


<!--
NOTE: Below is the hint (all within details tags collapsed)
-->
<details>

<summary style='text-decoration: underline; color: darkgreen;'>`r fontawesome::fa("lightbulb", fill = "gold")` Click to read a hint</summary>
</br>

Add `scale_fill_gradient()` to the `ggplot()` command. See the help documentation with `?scale_fill_gradient` to understand the arguments.  

</br>
</details>


<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r, echo=T, eval=F}
ggplot(data = hospital_weeks) +
  geom_tile(aes(x = week_onset, y = hospital, fill = n))+
  scale_fill_gradient(low = "skyblue", high = "tomato")

```
</br>
</details>



3) The default x-axis ticks show each month. Change these to efficiently show every two weeks (not show any duplicate information).


<!--
NOTE: Below is the hint (all within details tags collapsed)
-->
<details>

<summary style='text-decoration: underline; color: darkgreen;'>`r fontawesome::fa("lightbulb", fill = "gold")` Click to read a hint</summary>
</br>

Add `scale_x_date()` and set `date_breaks = "2 weeks"`, and `labels = scales::label_date_short()`  

</br>
</details>


4) Make the labels for the axes and legend more presentable.  

<!--
NOTE: Below is the hint (all within details tags collapsed)
-->
<details>

<summary style='text-decoration: underline; color: darkgreen;'>`r fontawesome::fa("lightbulb", fill = "gold")` Click to read a hint</summary>
</br>

Adjust the `labs()`. Recall that the legend title in this case is edited with `fill = ` because it was created by the fill.  

</br>
</details>



Below is all the solution code together:  

<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r eval = F, echo=T}
# Edit the dataset
hospital_weeks_adjusted <- hospital_weeks %>% 
  mutate(hospital = fct_explicit_na(hospital),
         hospital = fct_relevel(hospital, "Central Hospital", "Military Hospital", "Port Hospital", "SMMH", "Other", "(Missing)"))

# Plot with adjustments
ggplot(data = hospital_weeks) +
  geom_tile(aes(x = week_onset, y = hospital, fill = n))+
  scale_fill_gradient(low = "skyblue", high = "tomato")+
  scale_x_date(date_breaks = "2 weeks",
               labels = scales::label_date_short())+
  labs(x = "Week of symptom onset",
       y = "Hospital",
       fill = "Number of\nweekly cases")+
  theme_minimal()

```
</br>
</details>








### Setting up the data, creating and customising a heat plot

Note that to make the heat plot using `geom_tile()`, you had to provide a data frame with *counts* - aggregated data (not a linelist). There are ways to create heat plots from linelist data (see `geom_density()` functions) but those will not be covered today.  

Now that you are familiar with the plotting syntax, we will move to an exercise where you create the counts data frame and further customize the plot display.  


`r fontawesome::fa("terminal", fill = "black")` Try to do the following on your own. It will be challenging, but this is good exposure to intermediate-level R programming.  

1) Use `combined` to create a new data frame named `age_outcome_summary`.  
  * First, drop any rows with  `NA` values by piping to `drop_na(gender, age_cat)`.  
  * Then, use `group_by()` and `summarise()` to show summary counts for each unique combination (group) of `age_cat` and `gender`.  
  * In addition to case counts, include a column showing the number of rows in each group whose `outcome` is equal to "Death".  
  * Finally, include a column calculating with the proportion in each group equal to "Death".  


<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r, eval = F, echo = T}
# make new data frame summarizing age, gender, and deaths
age_outcome_summary <- combined %>%
  drop_na(gender, age_cat) %>%         # remove any NA values
  group_by(age_cat, gender) %>%        # group rows by age-gender groups
  summarise(                           # begin creating new summary columns
    n = n(),
    n_death = sum(outcome == "Death",  # sum the number of rows where outcome is Death
                  na.rm = TRUE),
    pct_death = n_death / n)           # create proportion dead in the group
```
</br>
</details>



2) Now, create a heat plot using this new data frame. Make the tiles be filled (color) according to the percent of those that have an outcome of "Death" as broken down by `gender` and `age_cat` in your data frame.  

If possible, do the following as well:  

* Clean up the axis names to "Age category", "Gender" and the legend title to `"Percent of\ncases fatal"`  
* Using the **viridis** package (`scale_fill_viridis()`) and pick a color scheme option (e.g. `option = "B"`), and set the scale `limits = c(0, 1)` to align with the proportions.  
* Add `geom_text()` to display the percent on each tile. Try this first by reading the documentation for `geom_text`.  
  * To display as percents, you will need to edit `labels = scales::percent()` within `aes()`. Round to one decimal place with `accuracy = 0.1`.  
  
<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r, eval = F, echo = T}
# make plot
ggplot(data = age_outcome_summary,            # use new data frame
       mapping = aes(x = gender,              # gender on x-axis
                     y = age_cat,             # age category on y-axis
                     fill = pct_death)) +     # fill (color) is shaded by the proportion dead
  geom_tile() +                               # display data as tiles  
  scale_fill_viridis(                         # adjust colors scale
    option = "B",                             # pick any option
    limits = c(0, 1)) +                       # set the limits to go from 0 to 1
  geom_text(                                  # add text over the tiles
    mapping = aes(
      label = scales::percent(                # show percents instead of proportions
        pct_death,
        accuracy = 0.1)))+
  labs(x = "Gender",                          # add labels
       y = "Age categories",
       fill = "Percent of\ncases fatal") +
  scale_fill_continuous(                      # adjust the values displayed in the legend
    labels = scales::percent)                 # to be percents (not proportions)



```
</br>
</details>



###
```{r quiz2}
quiz(
  question("Who has the highest proportion of 'Death' as a gender and age category?",
           answer("Male and 20-29", correct = TRUE),
           answer("Female and 20-29"),
           answer("Male and 50-59"),
           answer("Female and 40-49")
           ),
  question("Which gender has the oldest ages?",
           answer("Female"),
           answer("Male", correct = TRUE)
           )
)
```


Ok, good job! You have managed to build summary datasets for a heat plot and then customize the plot so that you can analyze the information.  

Even if you did not know how to do all of those edits to the ggplot, the purpose of that task was to expose you to a new plot and customization possibilities.  

You can always find sample code in the Heat Plots chapter of the [Epi R Handbook](https://www.epirhandbook.com/en/heat-plots.html?q=heat%20plot#heat-plots), and become more well-practiced later.  











## Epiweeks  


Before we discuss Epidemic curves, it is worth covering the creation of "weeks", or "epiweeks" (epidemiological weeks) in your data frame. You may want to create a new column that contains the "epiweek", based on a date such as `date_onset`, in order to create tables of the number of cases by week.  

There are many different ways to define what a "week" is. Likewise, some countries formulate epiweeks differently (e.g. starting on Sundays, Mondays, or Fridays). Most of the world uses weeks that begin on Mondays. There are several ways to do this in R. Below we present the most common approach in detail, and provide you with a reference sheet for the rest.  


### {lubridate} floor_date()  

In your code that cleans the `combined` dataset (after the joins are used to create it), add a `mutate()` function to create an `epiweek` column.  

Assign this new column to the function `floor_date()` from the package {lubridate}, with the following argument settings:  

1) the column of dates to use (`date_onset`)  
2) `unit = "week"` (this can be set to other values such as "month")  

This `floor_date()` function will return a *date*, that is the Sunday *prior* to the onset date - the "floor" Sunday. In effect, it is "rounding down" the date to previous Sunday.  

For example:  

```{r, echo=T}
floor_date(ymd("2022-03-25"), unit = "week")   # Returns the Sunday prior to Friday 25 March, 2022  
```

If you need to create epiweeks that begin on Monday, you can set the additional argument `week_start = 1` (Sundays are 7, and Mondays are 1).  

```{r, echo=T}
floor_date(ymd("2022-03-25"), unit = "week", week_start = 1)   # Returns the Monday prior to Friday 25 March, 2022  
```

**Now try adding another `mutate()` command that creates epiweek of report, using `date_report`.** But this time, adjust your first `mutate()` command so that you nest the creation of these two columns *within one `mutate()` command*. For example:  

```{r, echo=T, eval=F}
combined %>% 
  mutate(epiweek_onset  = floor_date(___),    # create first new column, followed by a comma
         epiweek_report = floor_date(___))    # create second new column, close mutate parentheses
```

This is one way to make your code more concise and efficient. Each mutate statement does not require its own `mutate()` command.  


<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r, eval = F, echo = T}
mutate(epiweek_onset = floor_date(date_onset, unit = "week", week_start = 1),
       epiweek_report = floor_date(date_onset, unit = "week", week_start = 1))
```
</br>
</details>













## Epi curves

An epidemic curve (also known as an “epi curve”) is a core epidemiological chart typically used to visualize the temporal pattern of illness onset among a cluster or epidemic of cases.

Analysis of the epicurve can reveal temporal trends, outliers, the magnitude of the outbreak, the most likely time period of exposure, time intervals between case generations, and can even help identify the mode of transmission of an unidentified disease (e.g. point source, continuous common source, person-to-person propagation).

We are going to build epidemic curves with {ggplot2}, which allows for advanced customizability. There is another option, the {incidence2} package as described in the [Epi R Handbook](https://epirhandbook.com/en/epidemic-curves.html#epicurves-with-incidence2-package), which is perhaps more simple but less customizeable.  






### {ggplot2} epicurves

As you have been through several exercises using {ggplot2}, you are now familiar with the syntax and customization it allows (themes, labels, axes, etc). 

In its most basic form, plotting epidemic curves in {ggplot2} is a case of using the ggplot function `geom_histogram()`. However, there are 3 main things to watch out for:  

* The histogram bins (how the data are grouped by time unit)  
* Scales for axes and their labels
* Themes for the plot appearance

### Simple bins  

`r fontawesome::fa("terminal", fill = "black")` Can you make a simple histogram from the data frame `combined` which shows the incidence of `date_onset` using 5-day intervals? The histogram "binwidth" can be specified as a number (a static aesthetic) to `binwidth = `. Also, clean up the labels and use `theme_bw()`.  

<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r, eval = F, echo = T}
ggplot(data = combined, mapping = aes(x = date_onset)) +
    geom_histogram(binwidth = 5) +
    labs(x = "Date of onset", y = "Incidence") +
    theme_bw()
```
</br>
</details>



### Defining manual bins  

Calculating incidence via binwidths works if we do not care about the specific days of the week used (the bins will start at the first case), and if we do not care about months (because months can be 28, 29, 30 or 31 days!).  

But as epidemiologists and public health practitioners, we usually care about the details. We typically need to produce an epidemic curve that adheres to very particular specifications. For example, cases binned by month, or by a 7-day week that starts on a particular day.  

In these cases, **instead of using `binwidth = `, we specify `breaks = `.**  

What does `breaks =` expect as a value? It expects a *vector* of dates to use as breaks (cut-points). 

How to make a vector of dates? We know that we can create a vector using `c()`, for example `c(54, 22, 89)` or `c("Paris", "Delhi", "Kigali")`.  

We can even make a vector of dates: `c(ymd("2014-06-15"), ymd("2014-06-22"), ymd("2014-06-29"))` But this would be have to be a very long code to include *all* the weekly break points throughout this outbreak!  

Instead we can use the {base} function `seq.Date()` to automatically create a *sequence* of dates between a `from = ` value, to a `to = ` value, and in increments specified to `by = `. You can specify `by` values such as "day", "week", "month", etc.  

The sequence below uses dates of the first and last case onsets.  

```{r, echo=T, eval=T}
seq.Date(from = ymd("2014-05-06"),
         to = ymd("2014-11-28"),
         by = "week")
```

So, we could write an epicurve command like the below:  

```{r, echo=T, eval=T, warning=F, message=F}
ggplot(data = combined, aes(x = date_onset))+
  geom_histogram(
    breaks = seq.Date(
      from = ymd("2014-05-06"),
      to = ymd("2014-11-28"),
      by = "week")) +
  labs(x = "Date of onset", y = "Incidence") +
  theme_bw()
```

Now we are confident that the breaks are using 7-day intervals from the first case to the last case.  

But typically we want the intervals to start on **Mondays** (or some other day), so we add `floor_date()` and it's companion `ceiling_date()` :  

```{r, echo=T, eval=T}
# Monday BEFORE the earliest case
floor_date(ymd("2014-05-06"), unit = "week", week_start = 1)

# Monday AFTER the last case
ceiling_date(ymd("2014-11-28"), unit = "week", week_start = 1)
```

And so now we can create a vector of Mondays from before the earliest case, to after the latest case.  

```{r,echo=T, eval=T}
# Sequence of Mondays from before earliest case, to after latest case
seq.Date(from = floor_date(ymd("2014-05-06"), unit = "week", week_start = 1),
         to =   ceiling_date(ymd("2014-11-28"), unit = "week", week_start = 1),
         by =   "week")
```

Finally, what happens if our data are refreshed or updated with new data? Those static dates in our code will not be current!  

Let's replace them with `min()` and `max()` applied to the column `combined$date_onset`.  

As this is not a {dplyr} pipe, we need to specify the data frame and column with the `$` index operator. Don't forget that these two functions need `na.rm=TRUE` to remove missing values.  

```{r, echo=T, eval=T}
seq.Date(from = floor_date(min(combined$date_onset, na.rm=T), unit = "week", week_start = 1),
         to =   ceiling_date(max(combined$date_onset, na.rm=T), unit = "week", week_start = 1),
         by =   "week")
```

In this way, we have made our code more *dynamic*. Dynamic code will be important if our dataset is refreshed/updated, so you want all the plots and tables to update automatically.  


Finally, the easiest way to insert this `seq.Date()` vector into the `ggplot()` command is by saving it in advance, with a name. So the command becomes two separate commands:  

```{r, echo=T, eval=F}
# Define and save the vector
ebola_weeks <- seq.Date(
  from = floor_date(min(combined$date_onset, na.rm=T), unit = "week", week_start = 1),
  to =   ceiling_date(max(combined$date_onset, na.rm=T), unit = "week", week_start = 1),
  by =   "week")

```


Now if you run just `ebola_weeks`, the vector is returned/printed. So we can provide `ebola_weeks` to the `breaks = ` argument of `geom_histogram()`.  

One final change before we finish is that we also add `closed = "left"` to `geom_histogram()` which sets the bars to also count the cases reported on the break days themselves.    

```{r, echo=T, eval=F}
# Define and save the vector
ebola_weeks <- seq.Date(
  from = floor_date(min(combined$date_onset, na.rm=T), unit = "week", week_start = 1),
  to =   ceiling_date(max(combined$date_onset, na.rm=T), unit = "week", week_start = 1),
  by =   "week")


# Run the plot, using the vector
ggplot(data = combined, aes(x = date_onset)) +
  geom_histogram(breaks = ebola_weeks, closed = "left") +
  labs(x = "Date of onset", y = "Incidence") +
  theme_bw()

```

Compare this plot to the histogram printed in the exercise above (7-days, no specified breaks). Do you see any small differences in how the cases have been binned? (look at the beginning of the epidemic).  

The above can seem like a lot of work to just produce a list of dates! But think of the control that you have over the output. And, now that you have this code it will be easy to modify. (Also this is all in the Epi R Handbook chapter on Epidemic Curves).

### Monthly epidemic curve  

`r fontawesome::fa("terminal", fill = "black")` Now it is your turn. Copy the code and make a new epidemic curve in which the histogram bin breaks are by *month* from the month-start prior to the first case, until the month-start after the last case. 

Once you have done this, adjust the code so that the `fill` in the bars is by hospital, and the x-axis labels appear every month.  


<!--
NOTE: Below is the hint (all within details tags collapsed)
-->
<details>

<summary style='text-decoration: underline; color: darkgreen;'>`r fontawesome::fa("lightbulb", fill = "gold")` Click to read a hint</summary>
</br>

As we want the values to be aggregated by calendar month, do the following:  

* Set the `unit =` to "month" in the two {lubridate} functions `floor_date()` and `ceiling_date()` and remove the `week_start` arguments (check `?floor_date` for details).  
* Change the `by = ` argument of `seq.Date()` to "month"  
* Change the name of the vector `ebola_weeks` to `ebola_months`, and change it in the `ggplot()` command too.  

* To set the fill, put `fill = hospital` in the aesthetic mappings  
* To adjust the x-axis labels, do the following within `scale_x_date()`:  
  * set `labels = date_label_easy()`  
  * set `date_breaks = "months"`  
  
</br>
</details>


<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r, eval = F, echo = T}
# define and save the vector (by month)
ebola_months <- seq.Date(
  from = floor_date(min(combined$date_onset, na.rm=T), unit = "month"),
  to =   ceiling_date(max(combined$date_onset, na.rm=T), unit = "month"),
  by =   "month")

# run the plot with monthly breaks, and fill
ggplot(data = combined, aes(x = date_onset, fill = hospital)) +
  geom_histogram(breaks = ebola_months, closed = "left") +
  scale_x_date(
    date_breaks = "months",
    labels = scales::label_date_short())+
  labs(x = "Date of onset", y = "Incidence") +
  theme_bw()
```
</br>
</details>




### Facets  

It may be difficult to read this epicurve and to understand the case trends from each hospital.  

*Faceting* the plots means creating "small-multiple" (mini plots) for each unique value in a column (e.g. `hospital`).  

You create facets by adding `facet_wrap()` to the ggplot. Within this function, write a tilde ~ and then the name of the column, for example:  

```{r, echo=T, eval=F}
facet_wrap(~gender)
```

**Now, create facets based on `hospital` for your epidemic curve.**  


<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r, eval = F, echo = T}
ggplot(data = combined, aes(x = date_onset, fill = hospital)) +
  geom_histogram(breaks = ebola_months, closed = "left") +
  scale_x_date(
    date_breaks = "months",
    labels = scales::label_date_short())+
  labs(x = "Date of onset", y = "Incidence") +
  theme_bw()+
  facet_wrap(~hospital)
```
</br>
</details>


There are MANY other adjustments that you can make to your epidemic curve made with {ggplot2}. Many of them are outlined in the [Epidemic curves chapter of the Epi R Handbook](https://epirhandbook.com/en/epidemic-curves.html#epidemic-curves).  








## Age pyramids

Age pyramids are a useful way of illustrating demographics, and can be customised in a variety of different ways. For our purposes, we will be using the function `age_pyramid()` from the **apyramid** package.  


### **apyramid**

The function `age_pyramid()` is fairly simple, in that it produces high quality age pyramids with relatively few arguments. 

It is good to practice trying to use a function by reading the documentation and trying to write the command yourself.  


`r fontawesome::fa("eye", fill = "darkblue")` Look up the documentation for the function (`?age_pyramid`). Review the arguments, and the examples.  

`r fontawesome::fa("terminal", fill = "black")` Now create an age pyramid using the `combined` data frame and the `age_cat` categories, that is split by `gender`.  





<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r, eval = F, echo = T}
age_pyramid(data = combined,
            age_group = "age_cat", #note that the column must be enclosed in quotation marks (" ")
            split_by = "gender")  #note that the column must be enclosed in quotation marks (" ")
```
</br>
</details>

You can also plot the values by proportion, rather than count, and include a column for missing data.

`r fontawesome::fa("terminal", fill = "black")` Can you now, after reading the instructions, create an age pyramid of gender that includes missing (`NA`) values and plots the proportion?

<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r, eval = F, echo = T}
age_pyramid(data = combined,
            age_group = "age_cat", #note that the column must be enclosed in quotation marks (" ")
            split_by = "gender",
            proportional = TRUE,
            na.rm = FALSE) 
```
</br>
</details>



### Counts

In the previous example, the data is in a linelist format, where each row is a unique observation. However, you may be given data that is already aggregated into counts.

Just to practice, create this dataset `demo_wide_counts` in your RStudio by running the following command:  

```{r, echo=T, eval=T}
# Creates the object demo_agg
#############################
demo_wide_counts <- structure(list(
  age_cat = structure(c(1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, NA),
                      .Label = c("0-9", "10-19", "20-29", "30-39", "40-49", "50-59", "60-69", "70+"), class = "factor"),
  female = c(149L, 104L, 55L, 15L, 4L, 1L, NA, NA, NA),
  male = c(96L, 80L, 65L, 39L, 19L, 5L, 5L, 1L, NA),
  missing_gender = c(5L, 4L, 4L, 2L, NA, NA, 1L, NA, 26L)),
  row.names = c(NA, -9L),
  class = c("tbl_df", "tbl", "data.frame"))
```

It should look like this:  


```{r, eval=T, echo=TRUE}
demo_wide_counts
```

To be acceptable to `age_pyramid()` the data must be in "long" format, so first, you would need to *pivot longer* so that the gender information is in one column (remember tidy data!) and the counts are in one column.  

You could use this command:  

```{r, echo=T, eval=T}
demo_long_counts <- demo_wide_counts %>% 
  pivot_longer(
    col = c(female, male, missing_gender),    # cols to elongate
    names_to = "gender",                      # name for new col of categories
    values_to = "counts") %>%                 # name for new col of counts
  mutate(
    gender = na_if(gender, "missing_gender")) # convert "missing_gender" to NA
```

Which results in: 
```{r, echo=T, eval=T}
demo_long_counts
```

Now, use your knowledge of the `age_pyramid()` documentation to adjust the plotting command to accept counts.  

<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r, eval = F, echo = T, warning=F, message=F}
age_pyramid(data = demo_long_counts,
            age_group = "age_cat", 
            split_by = "gender",
            count = "counts")
```
</br>
</details>


### Adding ggplot to age pyramids  

Finally, you can add ( + ) ggplot commands to {apyramid} age pyramids. For example, the code below adds labels and adjusts the color scale:  


```{r, message=F, warning=F, echo=T, eval=T}
# Age pyramid with ggplot modifications
age_pyramid(
     data = combined,
     age_group = "age_cat",
     split_by = "gender",
     proportional = TRUE,
     show_midpoint = FALSE)+
     
  theme_minimal()+
     
  scale_fill_brewer(type = "qual", palette = 2)+
  
  labs(title = "Age and gender of confirmed cases",
       x = "Proportion of all cases",
       y = "Age group",
       caption = "Ebola outbreak",
       fill = "Gender")
```



## End  

Congratulations! You have finished the exercise on heat plots, epidemic curves, and age/sex pyramids! These are some challenging plots that you have been making!  






<!-- ### **ggplot2** -->

<!-- Using `ggplot()` to build the age pyramid allows for much more flexibility, but requires more effort and an understanding of how `ggplot()` works. -->

<!-- There are several steps to constructing the age pyramid: -->

<!-- 1) Within the ggplot(), we need to create **two** histograms using the numeric age column. -->
<!-- 2) We generate the incidence values through the specifying `y = ..count..` -->
<!-- 3) One of these must have its counts converted to _negative_ values. This creates the "pyramid" with the value of 0 in the middle. Negative values are created by multiplying the column by -1. -->
<!-- 4) The command `coord_flip()` switches the X and Y axes is required to flip the axes and create the pyramid. -->
<!-- 5) Finally, the count-axis value labels must be altered so they appear as "positive" on both sides of the pyramid, despite the underlying values on one side being negative. -->

<!-- Considering you have already practiced using `geom_histogram()` for the epi curves, and given the instructions above. Can you re-create the a simple age pyramid, with age breaks ever 5 years, below? -->

<!-- ```{r, echo = F, eval = T} -->
<!-- # begin ggplot -->
<!--   ggplot(mapping = aes(x = age, fill = gender)) + -->

<!--   # female histogram -->
<!--   geom_histogram(data = combined %>% filter(gender == "female"), -->
<!--                  breaks = seq(0, 85, 5), -->
<!--                  colour = "white") + -->

<!--   # male histogram (values converted to negative) -->
<!--   geom_histogram(data = combined %>% filter(gender == "male"), -->
<!--                  breaks = seq(0,85,5), -->
<!--                  mapping = aes(y = ..count..*(-1)), -->
<!--                  colour = "white") + -->

<!--   # flip the X and Y axes -->
<!--   coord_flip() + -->

<!--   # adjust counts-axis scale -->
<!--   scale_y_continuous(limits = c(-100, 100), -->
<!--                      breaks = seq(-100,100,25), -->
<!--                      labels = abs(seq(-100, 100, 25)))+ -->
<!--   labs(y = "Count", x = "Age", fill = "Gender") -->
<!-- ``` -->

<!-- <details> -->
<!-- <summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary> -->
<!-- </br> -->
<!-- ```{r, eval = F, echo = T} -->
<!-- # begin ggplot -->
<!--   ggplot(mapping = aes(x = age, fill = gender)) + -->

<!--   # female histogram -->
<!--   geom_histogram(data = combined %>% filter(gender == "female"), -->
<!--                  breaks = seq(0, 85, 5), -->
<!--                  colour = "white") + -->

<!--   # male histogram (values converted to negative) -->
<!--   geom_histogram(data = combined %>% filter(gender == "male"), -->
<!--                  breaks = seq(0,85,5), -->
<!--                  mapping = aes(y = ..count..*(-1)), -->
<!--                  colour = "white") + -->

<!--   # flip the X and Y axes -->
<!--   coord_flip() + -->

<!--   # adjust counts-axis scale -->
<!--   scale_y_continuous(limits = c(-100, 100), -->
<!--                      breaks = seq(-100,100,25), -->
<!--                      labels = abs(seq(-100, 100, 25)))+ -->
<!--   labs(y = "Count", x = "Age", fill = "Gender") -->
<!-- ``` -->
<!-- </br> -->
<!-- </details> -->

<!-- Great, now what if we want to produce the percentages? In order to do this, we will need to group the data and use `mutate()` in order to produce new columns. -->

<!-- This part is a a lot more complicated than if we were using the **apyramid** function `age_pyramid()` -->

<!-- In order to create the percent values, we need to employ `mutate()` and the tidyselect helper function `case_when`. For example, this would be the command to generate the percent -->

<!-- ```{r, eval = F, echo = T} -->
<!--  mutate(percent = round(100*(counts / sum(counts, na.rm=T)), digits = 1),  -->
<!--          percent = case_when( -->
<!--             gender == "f" ~ percent, -->
<!--             gender == "m" ~ -percent,     # convert male to negative -->
<!--             TRUE          ~ NA_real_))    # NA val must by numeric as well -->
<!-- ``` -->

<!-- Can you add in the parts before this to assign aggregate values to an object called `pyramid_data` from `combined`? Once you've done this, can you produce the previous age pyramid, but showing percentages instead of counts, adjust axis scale and labels as necessary? -->

<!-- Remember, as in when creating an epi curve that has already been aggregated, you should use `geom_bar()` or `geom_col()` rather than `geom_histogram()` -->


<!-- <details> -->
<!-- <summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary> -->
<!-- </br> -->
<!-- ```{r, eval = F, echo = T} -->
<!-- # create dataset with proportion of total -->
<!-- pyramid_data <- combined %>% -->
<!--   count(age_cat, -->
<!--         gender, -->
<!--         name = "counts") %>%  -->
<!--   ungroup() %>%                 # ungroup so percents are not by group -->
<!--   mutate(percent = round(100*(counts / sum(counts, na.rm=T)), digits = 1),  -->
<!--          percent = case_when( -->
<!--             gender == "female" ~ percent, -->
<!--             gender == "male" ~ -percent,     # convert male to negative -->
<!--             TRUE          ~ NA_real_))    # NA val must by numeric as well -->


<!-- # begin ggplot -->
<!--   ggplot() + -->

<!--   # histogram -->
<!--   geom_col(data = pyramid_data, -->
<!--            mapping = aes( -->
<!--              x = age_cat, -->
<!--              y = percent, -->
<!--              fill = gender),          -->
<!--            colour = "white") +       # white around each bar -->

<!--   # flip the X and Y axes -->
<!--   coord_flip() + -->

<!--   # adjust counts-axis scale -->
<!--   scale_y_continuous(limits = c(-25, 25), -->
<!--                      breaks = seq(-25,25,25), -->
<!--                      labels = abs(seq(-25, 25, 25)))+ -->
<!--   labs(y = "Percent (%)", x = "Age", fill = "Gender") -->
<!-- ``` -->
<!-- </br> -->
<!-- </details> -->
